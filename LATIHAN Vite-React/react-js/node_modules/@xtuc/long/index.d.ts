export = Long;
export as namespace Long;

declare namespace Long { }

declare class Long {
    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as signed integers. See the from* functions below for more convenient ways of constructing Longs.
     */
    constructor(low: number, high?: number, unsigned?: boolean);

    /**
     * Maximum unsigned value.
     */
    static MAX_UNSIGNED_VALUE: Long;

    /**
     * Maximum signed value.
     */
    static MAX_VALUE: Long;

    /**
     * Minimum signed value.
     */
    static MIN_VALUE: Long;

    /**
     * Signed negative one.
     */
    static NEG_ONE: Long;

    /**
     * Signed one.
     */
    static ONE: Long;

    /**
     * Unsigned one.
     */
    static UONE: Long;

    /**
     * Unsigned zero.
     */
    static UZERO: Long;

    /**
     * Signed zero
     */
    static ZERO: Long;

    /**
     * The high 32 bits as a signed value.
     */
    high: number;

    /**
     * The low 32 bits as a signed value.
     */
    low: number;

    /**
     * Whether unsigned or not.
     */
    unsigned: boolean;

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is assumed to use 32 bits.
     */
    static fromBits(lowBits: number, highBits: number, unsigned?: boolean): Long;

    /**
     * Returns a Long representing the given 32 bit integer value.
     */
    static fromInt(value: number, unsigned?: boolean): Long;

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     */
    static fromNumber(value: number, unsigned?: boolean): Long;

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     */
    static fromString(str: string, unsigned?: boolean | number, radix?: number): Long;

    /**
     * Creates a Long from its byte representation.
     */
    static fromBytes(bytes: number[], unsigned?: boolean, le?: boolean): Long;

    /**
     * Creates a Long from its little endian byte representation.
     */
    static fromBytesLE(bytes: number[], unsigned?: boolean): Long;

    /**
     * Creates a Long from its big endian byte representation.
     */
    static fromBytesBE(bytes: number[], unsigned?: boolean): Long;

    /**
     * Tests if the specified object is a Long.
     */
    static isLong(obj: any): obj is Long;

    /**
     * Converts the specified value to a Long.
     */
    static fromValue(val: Long | number | string | {low: number, high: number, unsigned: boolean}, unsigned?: boolean): Long;

    /**
     * Returns the sum of this and the specified Long.
     */
    add(addend: number | Long | string): Long;

    /**
     * Returns the bitwise AND of this Long and the specified.
     */
    and(other: Long | number | string): Long;

    /**
     * Compares this Long's value with the specified's.
     */
    compare(other: Long | number | string): number;

    /**
     * Compares this Long's value with the specified's.
     */
    comp(other: Long | number | string): number;

    /**
     * Returns this Long divided by the specified.
     */
    divide(divisor: Long | number | string): Long;

    /**
     * Returns this Long divided by the specified.
     */
    div(divisor: Long | number | string): Long;

    /**
     * Tests if this Long's value equals the specified's.
     */
    equals